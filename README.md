На вход алгоритму подаётся куча и количество элементов в куче. В цикле извлекаем элементы из кучи и перемещаем текущий узел в конец, меняя его местами с самым первым узлом, а после вызываем функцию по исправлению кучи на уменьшенной на 1 узел куче (т.е. последний узел «отбрасываем»).

Испытания я проводил на куче, указанной ниже. 

<table>
  <tr>
    <td>
<p>18 10 12 8 9 10 4 5 3 7</p>
<p>7 10 12 8 9 10 4 5 3</p>
<p>3 10 10 8 9 7 4 5</p>
<p>5 9 10 8 3 7 4</p>
<p>4 9 7 8 3 5</p>
<p>5 8 7 4 3</p>
<p>3 5 7 4</p>
<p>4 5 3</p>
<p>3 4</p>
<p>3</p>
    </td>   
    <td>
      <img src="https://user-images.githubusercontent.com/86602542/209710056-09832ad3-7f7a-46c7-b79f-e2e43c1b782b.png"/>
    </td>
  </tr>
</table>
  
Итоговый ответ: **3 4 5 7 8 9 10 10 12 18**. Итераций вышло 12, хотя показал только 10 потому, что две оставшиеся итерации ушли на дополнительное исправление кучи.

<table>
  <tr>
    <td>
<p>

Что касаемо исследования зависимости скорости от количества элементов в массиве в алгоритме сортировки, я пришёл к выводу, что скорость алгоритма линейно-логарифмическая **O(nlgn)**.

</p>
<p>

Однако, в зависимости от стартовых условий, скорость может разниться. **В среднем и худшем случаем** она может быть **O(nlgn)**, **в лучшем O(n)**.

</p>
<p>

Если куча будет как бы **заранее отсортирована**, то перестановок будет ровно столько, сколько элементов в куче, т.е. **O(n)**.

</p>
    </td>   
    <td>
      <img width="1500px" src="https://user-images.githubusercontent.com/86602542/209711585-e977de0a-e2be-45a4-8c1c-06cba6192aa5.png"/>
    </td>
  </tr>
</table>